---
title: JAVA에서 락
date: 2025-03-06 17:26:21
categories: [JAVA]
tags: [cas, concurrent, lock, semaphore, multi-thread]
---
## 개요
이전 프로젝트에서 예약 시스템, 위치 데이터 구독 관리 시스템을 JAVA로 직접 구현한 적이 있었는데,
거의 처음으로 JAVA에서 지원해주는 동기화 도구들을 사용해봤었다. 당시에는 시간이 없어서
별도로 정리는 못했는데, 프로젝트가 끝난 지금 다시 회고해 보면서 JAVA에서 동기화 처리는 어떻게 지원하는지 다시 살펴보려고 한다.

# 동기화의 필요성

## 멀티스레딩

 자바 애플리케이션 개발 시 응답 속도와 CPU 활용 효율을 높이기 위해 멀티스레딩을 적용한다. 이 말을 알려면 멀티스레딩이 적용되지 않았을 때 상황을 상상해보면 좋다. 이러한 상황은 IO 연산과 같은 CPU가 필요 없는 연산이 많아질수록 더 차이를 느낄 수 있다.

 보통의 애플리케이션에서는 데이터를 저장하거나 불러오거나, 아니면 다른 프로세스에 요청을 보내는 등의 IO 연산이 자주 일어난다. 
 예를 들어, 물건의 가격의 총합을 구하는 프로그램을 만든다고 생각해보자. 각 물건마다 가격은 어떤 파일에 저장되어 있다. 이 프로그램을 사용하는 사람은 물건 A X개, 물건 B Y개를 산다고 입력을 했을 때, 파일에 저장되어 있는 물건 A, 물건 B의 가격 정보 없이는 뒤의 연산을 할 수 없다는 것을 알 수 있다. 뒤의 작업을 진행하기 위해서는 IO 연산을 통해 반드시 데이터를 받아와야 하므로 데이터를 받을 때까지 작업을 대기한다. 이 동안에는 CPU를 사용할 필요가 없기 때문에 운영체제는 이 작업 대신 다른 작업에서 이 CPU를 활용할 수 있도록 작업의 상태를 바꾸어 CPU를 할당받지 못하게 바꾼다. 데이터를 받아오게 되면 일종의 시그널을 보내 다시 작업의 상태를 복구하여 CPU 자원을 할당 받을 수 있게 바꾼다. 

 따라서 IO 연산이 많이 포함되면 포함될수록 일종의 "비활성화 된" 상태가 오래 지속되며, 내가 만든 프로그램을 계속해서 중단된 상태가 될 것이다. 요청을 받는 것도 작업에 포함되기 때문에 중단된 상태에서는 다음 요청은 아예 받지도 못한다.

 이러한 문제를 해결하기 위해 요청을 받는 부분과 받은 요청을 실행하는 부분을 별도의 작업으로 분리하는 방법을 사람들은 생각해냈다. 이 방법을 적용하면 이전 요청에 대한 작업이 완료되지 않았더라도 다음 요청을 받아 실행하기 "시작"할 수 있었고, 그 방법 중 한 가지가 "멀티스레딩"이다.

---
## 멀티스레딩의 문제점

 멀티스레딩을 통해 만들어진 여러 개의 요청을 처리하는 스레드들이 서로 독립적이라면 큰 문제는 없지만, 서로의 작업에 영향을 주게 될 때 문제가 발생한다. 보통 Heap 영역에서 여러 스레드들이 공유하는 메모리에 접근하여 이 데이터를 수정하는 식으로 영향을 줄 때 문제가 발생한다. 
 예를 들면 선착순으로 5명에게만 쿠폰을 나눠주는 서비스를 생각해 볼 수 있다. 쿠폰을 발급하는 스레드들은 모두 남은 쿠폰 수라는 다른 스레드들과 공유하는 메모리를 참조하며 작업을 수행할 것이다. 흐름은 다음과 같을 것이다.

1. 남은 쿠폰 수가 1개 이상인지 확인
2. 1개 이상이라면 남은 쿠폰 수를 하나 깎고 쿠폰 발급 

 멀티 스레드 환경에서는 위 작업이 동시에 여러 개가 실행될 수 있다. 이 때 이를 실행할 수 있는 코어가 하나라고 하면 남은 쿠폰 개수가 1개일 때 요청 스레드 T1, T2, T3는 다음과 같은 순서로 실행될 수 있다.

(T1-1) -> (T2-1) -> (T3-1) -> (T1-2) -> (T2-2) -> (T3-2)

이렇게 실행되면 3개의 스레드 모두 쿠폰을 정상적으로 발급하게 된다.

 이렇게 된 이유는 T1-1, T1-2 사이에 T2-1, T3-1가 끼어들었기 때문이다. 이렇게 가운데에 함부로 누가 끼어들어 실행되면 안되는 코드 영역을 크리티컬 영역이라고 하며, 이 크리티컬 영역에 한 스레드만 독점적으로 실행하도록 하기 위해 만들어진 장치 중 하나가 락이다.
  
> 이런 상황이 항상 발생하는 것은 아니고, 그때 그때 운영체제가 판단하기에 따라 달라진다. 하지만 가능성이 있다는 점에서 막아야 한다.

## JAVA에서의 해결방법

위에서 소개한 락은 이러한 문제를 해결하는 방법 중 하나이고, 락 안에서도 여러가지 종류가 있으며,
락 말고도 이런 문제를 해결하는 방법이 있다.

먼저 락에 대해서 살펴보겠다.
락도 프로그래밍 언어마다, 아니면 실행환경(OS, JVM ..)에 따라서 기본 기능은 비슷하지만 조금씩 기능이 다르다. JAVA에서는 어떤 것들을 지원해줄까?

### 초기 자바 버전 (JDK 1.0 - 1.4)

#### Synchronized 키워드
이 키워드를 붙여 선언한 메서드를 실행하면 한 스레드에서 실행한 결과를 이를 대기하는 다른 스레드에서 제대로 볼 수 있다는 것을 보장할 수 있고, 동시성 문제도 방지할 수 있다.

>[!tip] 컴파일러에 의한 최적화와 메모리 가시성 문제 
>다른 스레드에서 연산된 결과를 현재 스레드에서 당연히 볼 수 있다고 생각할 수 있는데 실제론 그렇지 않을 수 있다. 코어마다 레지스터에 메모리에 있는 값을 올려 계산하는데, 메모리 접근엔 비용이 높아 최대한 컴파일 할 때 자주 쓰이는 값들은 한번 가져온 데이터를 바로 메모리에 보내지 않고 계속 레지스터에 유지해 놓는 식으로 최적화를 하게 된다. 이러한 경우 코어A를 쓰는 스레드에서 메모리에 값을 변경해도, 코어 B를 쓰는 스레드에서는 이 변경 사항을 반영하지 못하는 문제가 발생한다. 이러한 문제를 해결하기 위해 **volatile** 같은 키워드를 두어, 컴파일러에게 반드시 필요할 때마다 메모리를 읽도록 유도할 수 있다.

Synchronized 키워드는 다음 네 가지 앞에 붙여 쓸 수 있다.
1. 정적 메서드 선언부
	클래스 기준으로 동기화, 같은 클래스라면 동시에 하나의 스레드만 접근 가능 
	
2. 인스턴스 메서드 선언부
	객체 인스턴스 기준으로 동기화, 같은 인스턴스화 된 객체 메서드에 동시에 하나의 스레드만 접근 가능 
	
3. 정적 메서드 내의 코드 블럭 + 객체
	메서드 내의 다른 부분은 동시에 실행 가능하지만, synchronized 블럭 내의 코드는 동시에 하나의 스레드만 실행 가능, 역시 클래스 단위로 동기화 처리됨.

4. 인스턴스 메서드 내의 코드 블럭 + 객체
	메서드 내의 다른 부분은 동시에 실행 가능하지만, synchronized 블럭 내의 코드는 동시에 하나의 스레드만 실행 가능, 역시 인스턴스 단위로 동기화 처리됨.

sychronized 키워드는 간단하게 사용할 수 있고, 필요한 부분만 동기화 처리도 할 수 있지만, 간단한 만큼 편의 기능이 부족한 면이 있다.

**Synchronized의 문제점**
다른 스레드는 실행 중인 스레드가 synchronized 메서드나 코드 블럭을 종료할 때 까지 무한히 대기할 수 밖에 없음.
외부에서 이를 간섭할 수 있는 수단이 없어 sychronized만으로는 이런 대기 상태를 끊을 수 없음.	
이 문제는 마찬가지로 데드락을 예방하지 않고 발견하고 해결하려 하는 방법은 사용할 수 없다는 것을 의미한다.

> [!tip] wait/notify로 Synchronized 진입 시점을 내가 원하는 시점으로 미루기
> Object메서드의 wait, notify(notifyAll) 메서드를 이용하면 필요한 시점에 임계구역에 진입할 수 있다.
 
### 자바 5

자바 5에서는 이러한 동시성 문제를 해결하기 위한 좀 더 고수준의 도구들이 추가되었다.
